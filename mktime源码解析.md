# mktime源码解析

## 1. 简介

Linux从`date`获取的时间是年月日时分秒存储的，而系统更加倾向于使用秒或毫秒为单位的时间类型，这里就需要算法进行转化。

![image-20210429110915395](C:\Users\18113\AppData\Roaming\Typora\typora-user-images\image-20210429110915395.png)

由于公历存在大小月和闰年的问题，传统的处理方法是用数组存储每个月的月份，导致代码将十分冗长。而Linux的源码仅仅使用了几行就完成了时间的转化，可以计算从1970年1月1日到今天的时间，源码如下：

```c
 static inline unsigned long  mktime ( unsigned int  year, unsigned int  mon,
    unsigned int  day, unsigned int  hour,
    unsigned int  min, unsigned int  sec)
         {
    if (0 >= (int) (mon -= 2)) {    /* 1..12 -> 11,12,1..10 */
         mon += 12;      /* Puts Feb last since it has leap day */
         year -= 1;
    }

    return (((
             (unsigned long) (year/4 - year/100 + year/400 + 367*mon/12 + day) +
             year*365 - 719499
          )*24 + hour /* now have hours */
       )*60 + min /* now have minutes */
    )*60 + sec; /* finally seconds */
}
```

初见代码让人毫无头绪，可以直接从`return`处进行分析。

首先很容易看到这里是首先计算天数，之后将天数转化为秒，因此关键在于此天数如何计算。其公式为：
$$
X = Year/4 -Year/100+Year/400+367\times Mon/12+Day+Year\times365-719499
$$
公式较长，可以拆分为以下几个部分：

$Y = Year/4-Year/100+Year/400$

这个部分较简单，用于计算公元元年到现在的闰年数。

$W = Year\times365+Day$

由此公式可以看出，该算法假设所有的年均为正常年3656天，之后再加上额外天数$Y$

难以理解的是其余两个公式：

$Z = 367\times Mon/12$

$X=Y+Z+W-719499$

### 2. 大小月处理和闰月

首先看Z是如何获得

在源码中还存在一段`if`语句块：

```c
 mon  -=   2 ;
 if  (mon  <=   0 )  {
    mon += 12;
    year--;
}
```

这一段的意思是将每年的1月和2月作为前一年的最后两个月，3月作为下一年的第一个月。基于此可以尽可能减少闰月的影响。

首先研究0001年1月1日的情况，此时：

```c
mon = 1
mon -=2
year --
此时Y=0，mon=11
Z = 367*11+12 = 336
W = 1+0*365 = 1
Y+Z+W = 337
```

我们知道从元年到公元1970年1月1日的时间为719162天，由于公元元年的“起始”天数为337天，因此在计算时应该减去337，即为719499天，这解释了源码中X的来源。

之后再看mon的计算，即Z式。367似乎毫无道理，尝试穷尽mon查看结果：

        mon         Z
        1           30
        2           61
        3           91
        4           122
        5           152
        6           183
        7           214
        8           244
        9           275
        10          305
        11          336
        12          367
    将相邻的Z相减：
        mon         dZ
        1           30
        2           31
        3           30
        4           31
        5           30
        6           31
        7           31
        8           30
        9           31
        10          30
        11          31
        12          31
再按照`if`将月份修改：

        mon     org-mon         dZ
        1       3               30
        2       4               31
        3       5               30
        4       6               31
        5       7               30
        6       8               31
        7       9               31
        8       10              30
        9       11              31
        10      12              30
        11      1               31
        12      2               31
这个特殊的$367*x/12$实现了大小月的效果，这个现象由数学家`Gauss`发现。

我们看到这里原本是“大月”的3月变成了30天，假设今天是1月1日，那么按照这个公式今年已经过去31天，这显然是错误的。假如今天是5月1日，那么距离3月1日已经过去了62天。

我们假设一年从3月开始到次年2月结束，那么3月这个月份存在问题，因此可以在公式中减去30天。

对于从3月开始考虑可以这样理解，由于从3月开始，次年的2月无需特殊考虑，因为已经被年份处理过了。假如今年走到了2月28日，算法中将月份作为去年的12月份考虑，*此时就无需考虑闰月了*。再假如显示是5月1日，按照算法计算是3月，那么今年已经“过去”61天，加上额外的59天为120天。那么有可能会有人问，如此计算是按照正常年来进行，假如今年是闰年怎么办？由于我们已经减去了年份，故今年的日期计算是相当于在公元元年计算，而公元元年为正常年。

继续讨论源码的细节，由于今天和今年都没有经过，那么年数和天数都应当减去1，最终整理如下：

```
 Y = (year - 1) * 365 + year / 4 - year / 100 + year / 400
 M = 367 * mon / 12 - 30 + 59
 D = day - 1
 X = Y + M + D - 719162
 T = ((X * 24 + hour) * 60 + min) * 60 + sec
```

## 3. Reference List

1. [Linux源码中的mktime算法解析_axx1611的专栏-CSDN博客_mktime源码](https://blog.csdn.net/axx1611/article/details/1792827?reload)

