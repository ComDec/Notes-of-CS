# 正则表达式

* Xi Wang

  [toc]

## 第一节：基础知识点
### 1. 元字符

元字符是构造正则表达式的基本元素。

| 元字符 | 说明                         |
| ------ | ---------------------------- |
| `.`    | 匹配换行符外任意字符         |
| `\w`   | 匹配字母，下划线，数字或汉字 |
| `\s`   | 匹配任意空白字符             |
| `\d`   | 匹配数字                     |
| `\b`   | 匹配单词的起始或末尾         |
| `^`    | 匹配字符串开头               |
| `$`    | 匹配字符串结尾               |
| `\<`   | 匹配单词开头位置             |
| `\>`   | 匹配单词结尾位置             |

示例：

```javascript
// 匹配abc开头字符串
\babc
^abc
// 匹配1开头的八位qq号码,注意要在结尾限定
\b1\d\d\d\d\d\d\d$
```

### 2.重复限定符

注意重复限定符都是对**前置字符**的重复！

| Syntax  | Instruments   |
| ------- | ------------- |
| `*`     | 重复0-N次     |
| `+`     | 重复1-N次     |
| `?`     | 重复0或1次    |
| `{n}`   | 重复n次       |
| `{n,}`  | 重复n次或多次 |
| `{n,m}` | 重复N-M次     |

示例：

```javascript
// 匹配1开头的8位qq号码
^1\d{7}$
// 匹配a开头，0或多个b结尾的字符串
^(a)(b)*$
```

### 3. 分组

正则表达式用小括号()进行分组，即将括号中的内容作为一个整体。

如匹配包含多个ab开头的字符串：

```javascript
^(ab)*
```

### 4. 转义

如果要匹配含小括号的元素，需要使用转义字符。

如匹配(ab)开头的字符串：

```javascript
^(\(ab\))$
```

### 5. 条件或和区间

联通手机号码有不同的号段，若匹配联通的电话号码，可以使用或表达式。

```javascript
^(130|131|132|155|156|185|186|145|176)\d{8}$
```

<img src="C:\Users\18113\Desktop\生物计算编程语言和Linux系统\笔记\正则表达式.assets\image-20210331104515504.png" alt="image-20210331104515504" style="zoom:67%;" />

区间，使用`[]`进行限定，匹配`[]`中一个字符。

```javascript
//匹配数字
[1-3]
//匹配字符
[abcdes]
//数字限定
[285]
```

重复字符将被忽略。

```javascript
[abcdacbd]
```

<img src="C:\Users\18113\Desktop\生物计算编程语言和Linux系统\笔记\正则表达式.assets\image-20210331104814470.png" alt="image-20210331104814470" style="zoom:70%;" />

## 第二节：进阶知识点

### 1. 零宽断言

* 断言：正则可以在指定的内容的前面或后面出现满足规则的内容

  如字符串`"ss1aa2bb3"`，可以使用断言找出aa2后面有bb3.

* 零宽：没有宽度。在正则中断言只匹配位置不占据字符，即匹配结果不返回断言本身

### 2. 正向先(后)行断言

* 语法：`(?=pattren)`
* 作用：匹配pattern表达式前面的内容，不返回本身

示例：获取CSDN文章阅读量

```javascript
// String = "<span class="read-count">阅读数：641</span>"
```

在这里就可以使用正向先行断言来匹配`</span>`前面的数字。

```javascript
\d+(?=\<\/span>)$
```

![image-20210331111427901](C:\Users\18113\Desktop\生物计算编程语言和Linux系统\笔记\正则表达式.assets\image-20210331111427901.png)

* 语法：`(?<=pattern)`

* 说明：匹配pattern表达式后面的内容，不返回本身

这里也可以使用正向后行断言来获取阅读量。

```javascript
(?<=\<\/span class="read-count">)\d+
```

在Java的RegEx中不支持`<=`语法，表达式的位置即可决定先行和后行。

### 3. 负向先（后）行断言

和正向的语法类似，即寻找非pattern表达式前面或后面的内容。

* 语法：`(?!pattern)`

如下示例：

```bash
#寻找def前的abc字符
echo "abcdabcdef" | grep -P "[abc](?!def)"
```

注意正向和负向的区别：

![image-20210331151800441](C:\Users\18113\Desktop\生物计算编程语言和Linux系统\笔记\正则表达式.assets\image-20210331151800441.png)

无论是正向和负向，都要求“紧密”连接。

![image-20210331152449582](C:\Users\18113\Desktop\生物计算编程语言和Linux系统\笔记\正则表达式.assets\image-20210331152449582.png)

![image-20210331152904760](C:\Users\18113\Desktop\生物计算编程语言和Linux系统\笔记\正则表达式.assets\image-20210331152904760.png)

正向后行断言中，由于断言本身不占据宽度，故abc后第一个`[abc]`是断言abc的c。

![image-20210331152553744](C:\Users\18113\Desktop\生物计算编程语言和Linux系统\笔记\正则表达式.assets\image-20210331152553744.png)

同样的道理，看第二个正则表达式。不在da后面的`[abc]`，由于a匹配`[abc]`，故匹配到bc。

>后行断言必须指明宽度

### 4. 捕获和非捕获

捕获的字面意思即为匹配表达式，但捕获通常和分组联系到一起，即“`捕获组`”。

> 捕获组：匹配子表达式的内容，并将匹配结果保存到内存中的组中。按照深优先的方式对组进行编号，之后可以通过序号或名称访问和使用匹配结果。

#### 4.1 数字编号捕获组

* 语法：`(exp)`

* 从表达式左侧开始，每一个括号对于一个分组。0对于整个表达式，从1-N表示依次出现的括号表达式。

如固定电话的表达式：

```javascript
(0\d{2})-(\d{8})
```

<img src="C:\Users\18113\Desktop\生物计算编程语言和Linux系统\笔记\正则表达式.assets\image-20210331154232053.png" alt="image-20210331154232053" style="zoom:67%;" />

#### 4.2 命名编号捕获组

* 语法：`(?<name>exp)`

* 分组的命名由表达式中的name指定

上面的例子也可以写作：

```javascript
(?<head>0\d{2})-(?<end>\d{8})
```

#### 4.3 非捕获组

* 语法：`(?:exp)`

* 解释：用于标记不需要捕获的分组

```javascript
(?:^(020))-(\d{8})
```

`\1`的内容为：`\d{8}`

<img src="C:\Users\18113\Desktop\生物计算编程语言和Linux系统\笔记\正则表达式.assets\image-20210331170012780.png" alt="image-20210331170012780" style="zoom:67%;" />

#### 4.4 反向引用

捕获会返回一个捕获组，这个保存在内存中的组，不仅可以在正则表达式的外部通过程序进行引用，可以在表达式内部引用。

反向引用可以分为数字编号组和命名编号组反向引用。

1. 数字编号组：`\number`

2. 命名编号组：`\'name'`

示例：寻找string中成对的字符。

```javascript
(\w)\1
```

### 5. 贪婪和非贪婪

#### 5.1 贪婪

贪婪匹配：在正则表达式中包含可接受重复的限定符时，匹配尽可能多的字符。通常过程是，一次读入整个字符串进行匹配，每当不匹配就舍弃最右边的字符后继续匹配和舍弃，直至把整个字符串舍弃完。

如下例子：

```javascript
\d{3,6}
```

匹配重复3-6次的数据，这是个贪婪匹配模式。

```bash
echo "1234 22 566663 2 2235 3233236" | grep -P "\d{3,6}"
```

![image-20210331161324089](C:\Users\18113\Desktop\生物计算编程语言和Linux系统\笔记\正则表达式.assets\image-20210331161324089.png)

这种匹配会匹配输入字符串中所有可能的模式，只多不少。

![image-20210331161527612](C:\Users\18113\Desktop\生物计算编程语言和Linux系统\笔记\正则表达式.assets\image-20210331161527612.png)

当多个贪婪叠加到一起，字符串能够满足各自的最大程度匹配时将互不干扰。若不能满足则根据深度优先原则，即从左至右的每一个贪婪量词，优先最大数量满足，余下的再分配下一个量词。

![image-20210331162129537](C:\Users\18113\Desktop\生物计算编程语言和Linux系统\笔记\正则表达式.assets\image-20210331162129537.png)

第一个字符节中，可以满足两者的最大要求。第二个字符节由于数量不足，故满足最大贪婪量词数量。

#### 5.2 懒惰

懒惰匹配：和贪婪相反，匹配尽可能少的字符。从字符串左至右匹配。每次试图不读入字符匹配，若匹配成功则完成全部匹配，否则读入一个字符再匹配。

* 语法：在贪婪量词后添加`?`

<img src="C:\Users\18113\Desktop\生物计算编程语言和Linux系统\笔记\正则表达式.assets\image-20210331162710289.png" alt="image-20210331162710289" style="zoom:67%;" />

示例如下：

```bash
echo "123456655 222222" | grep -P "\d{3,6}?\d{2}?"
```

![image-20210331162751557](C:\Users\18113\Desktop\生物计算编程语言和Linux系统\笔记\正则表达式.assets\image-20210331162751557.png)

### 6.反义

如下是一些反义元字符，用于匹配不是XX的字符。

| 元字符     | 说明                                   |
| ---------- | -------------------------------------- |
| `\W`       | 匹配不是字母，数字，下划线和汉字的字符 |
| `\S`       | 匹配任意不是空白符的字符               |
| `\D`       | 匹配任意非数字的字符                   |
| `\B`       | 匹配非单词开头或结束的位置             |
| `[^x]`     | 匹配除x外任意字符                      |
| `[^aeiou]` | 匹配除aeiou这几个字母外任意字符        |

![image-20210331164414756](C:\Users\18113\Desktop\生物计算编程语言和Linux系统\笔记\正则表达式.assets\image-20210331164414756.png)

### 7. 运算优先级

![image-20210331164658087](C:\Users\18113\Desktop\生物计算编程语言和Linux系统\笔记\正则表达式.assets\image-20210331164658087.png)

## 第三节：RegEX高级

